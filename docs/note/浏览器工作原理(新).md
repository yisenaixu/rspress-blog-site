# 浏览器工作原理

浏览器主要做的 **加载页面**

## 加载页面的流程

- 输入URL
- DNS查询【有域名】
- TCP建立连接（三次握手）
- TLS建立连接（四次握手）【使用HTTPS协议】
- 发送请求，拿到响应【通常是HTML文件】
- **解析**HTML，**构建**DOM树
- 解析HTML 会遇到 图片 ，css文件 ，js文件等。
- 图片，会请求对应资源，不阻碍解析
- css文件，请求对应资源，不阻碍解析，阻碍渲染
- js文件， 执行阻碍解析和渲染

> 浏览器渲染器进程中 GUI线程与js线程互斥，所以执行js时阻碍解析。 为什么这么设计？ js中可能对html元素进行更改，所以等待js执行完再解析可以避免重新解析。

- **解析**CSS，**构建**CSSOM树

  > **解析HTML和解析CSS应当视为并行的，HTML加载CSS资源后CSS被解析**

- 进入**渲染**流程

- 将DOM树和CSSOM树合并为一颗渲染树（包含节点内容和样式）

- **布局（layout）** 确定每个节点的位置属性（包括宽高和position）。第一次以外的布局操作成为**重排**。

  > ​       造成重排的原因：元素大小变化或位置变化
  >
  > - 更改元素的width和height或者postion
  > - 更改元素内的文字，导致元素width变化
  > - 图片未加载和加载后
  > - 增加删除元素
  
- **绘制（paint）** 将每个元素的**可见部分**绘制到屏幕上，浏览器（60帧）要求每16.67ms完成一次这些操作，因此浏览器采取**分层**的措施来提高绘制和重新绘制的性能。

- 由此产生了**合成（compose）** ，合成时需要确定绘制顺序（层的上下级关系），将层按照正确顺序绘制到页面上。

- 之后就准备完毕，可以**交互**

  > 交互与**事件触发线程 IO线程**有关，交互产生事件，事件回调将函数加入js线程执行任务队列，js单线程，一次只能处理一个任务，所以如果此时js脚本（由onload触发）仍在执行，那么**交互（IO线程）**将无法执行，也就是鼠标触摸滚动都无法使用。







