## 作用域与闭包

### **作用域**

- 全局作用域
- 函数作用域
- 块级作用域（let const实现）

### **var的问题**

var作为js最早声明的方式（至少我现在完全没主要使用过）

- 没有块级作用域（之前使用IIFE实现）
- 声明提升
- 可重复声明

```js
// 经典问题
for(var i =0;i<10;i++) {
  setTimeout(() => {
    console.log(i)
  },0)
}
//结果?
10 * 10
//原因分析
1.var没有块级作用域
2.setTimeout延迟执行（事件循环机制）,此时循环执行结束，i为全局变量此时 = 10
```

### **闭包**

代码块 `{}` ,`{}`也指块级作用域

我习惯认为一个代码块对应一个块级作用域，对应一个词法环境

js**所有函数天生闭包**，因为**词法环境**的存在

词法环境记录当前作用域内的所有函数和变量的声明，因此即使函数在其他地方被调用，他依然可以通过词法环境去找到处于他声明位置的外部变量，词法环境通过outer属性由内向外链接，同时也是查找的顺序，由内向外。

及闭包的定义是函数可以记住外部变量并且访问它。

**应用**

- 函数柯里化

```
function curry(fn) {
  
}
```

- 函数防抖，函数节流

```
function debounce() {

}
```

- 私有化变量

缺点

- 可能造成内存泄漏（与回收机制有关）

## 函数对象

**js中一切都是对象**

函数作为对象的主要属性

- name 函数名
- length 函数参数数量，不计算rest参数

特别的命名函数表达式，**安全的内部重复调用方法**

```js
let sayHi = function func(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    func("Guest"); // 使用 func 再次调用函数自身
  }
};
```

## this指向

与执行上下文有关，使用箭头函数绑定函数的执行上下文在声明时。

不会因为函数在其他地方调用引起执行上下文变化而改变this造成一些bug

一般解决方法

- 使用箭头函数固定this在函数声明时
- 绑定this， apply，call，bind

